
1. 并发控制
     1.1 起因
并发：多个执行单元同时被执行。
竞态：并发的执行单元同时访问同一个共享资源。
举例：对称多处理器（SMP）竞态、单CPU内进程与抢占它的进程竞态、中断（硬中断、软中断、tasklet、底半部）与进程之间竞态。
    1.2 控制方法
中断屏蔽
原子操作
自旋锁
信号量
2. 中断机制
 申请和释放中断
使能和屏蔽中断
底半部机制
3. 阻塞机制
阻塞机制（等待队列）
1. 定义等待队列头变量（全局）；
2. open()中初始化等待队列头；
3. read()中进入休眠（插入队列、改变状态、进程调度）；
4. irq_handle()唤醒进程；
5. read()执行完。

poll机制（轮询机制：多文件）
1. 定义一个等待队列头（全局）；
2. open()初始化等待队列头；
3. poll()插入等待队列（挂入队列、查询是否有事件）；
4. irq_handle()唤醒；
5. read()；

4. 异步机制
    4.1应用编程
1.将信号与信号处理函数绑定；
2.实现信号处理函数；
3.设置信号的拥有者为本进程，将file结构体与pid绑定fcntl(fd,F_SETOWN,getpid())；
4.设置为异步通知的模式。

    4.2 驱动编程
1.定义一个Struct fasync_struct 结构体；
2.fasync()设置fasync_struct结构体；
3.irq_handle()发信号。

5. 设备打开
fd =open("设备文件"，权限)，完成了如下任务：

1.创建file和fd；
2.根据设备文件路径找到设备文件对应的inode结构体；
3.将inode结构体中的i_fop成员赋值给file结构体中的f_op成员；
           f->f_op = fops_get(inode->i_fop)
4.调用file中的f_op成员中的open函数；
6.搜索内核中的一个哈希表，根据主设备号找到对应的cdev结构体；
7.将cdev结构体中的ops赋值给file中的f_op成员，
           filp->f_op = fops_get(p->ops);  
8.调用file中的f_op成员中的open函数，实际就是驱动人员写的xxx_open函数。

6. 设备读写
write(fd,&val,1)  read(fd, &val, 1)，完成了如下任务：

1. 根据fd找到相应的file结构体；
2. 调用file中的f_op成员中的write/read函数，实际就是调用xxx_write函数。

7. 内核定时器


8. 内存映射




注：个人学习，不妥望指正，持续改善中。
